// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"locathlete-server/ent/athlete"
	"locathlete-server/ent/athleteschool"
	"locathlete-server/ent/predicate"
	"locathlete-server/ent/school"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAthlete       = "Athlete"
	TypeAthleteSchool = "AthleteSchool"
	TypeSchool        = "School"
)

// AthleteMutation represents an operation that mutates the Athlete nodes in the graph.
type AthleteMutation struct {
	config
	op             Op
	typ            string
	id             *int
	bio            *string
	first_name     *string
	middle_name    *string
	last_name      *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	schools        map[int]struct{}
	removedschools map[int]struct{}
	clearedschools bool
	done           bool
	oldValue       func(context.Context) (*Athlete, error)
	predicates     []predicate.Athlete
}

var _ ent.Mutation = (*AthleteMutation)(nil)

// athleteOption allows management of the mutation configuration using functional options.
type athleteOption func(*AthleteMutation)

// newAthleteMutation creates new mutation for the Athlete entity.
func newAthleteMutation(c config, op Op, opts ...athleteOption) *AthleteMutation {
	m := &AthleteMutation{
		config:        c,
		op:            op,
		typ:           TypeAthlete,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAthleteID sets the ID field of the mutation.
func withAthleteID(id int) athleteOption {
	return func(m *AthleteMutation) {
		var (
			err   error
			once  sync.Once
			value *Athlete
		)
		m.oldValue = func(ctx context.Context) (*Athlete, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Athlete.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAthlete sets the old Athlete of the mutation.
func withAthlete(node *Athlete) athleteOption {
	return func(m *AthleteMutation) {
		m.oldValue = func(context.Context) (*Athlete, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AthleteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AthleteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AthleteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AthleteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Athlete.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBio sets the "bio" field.
func (m *AthleteMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *AthleteMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the Athlete entity.
// If the Athlete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AthleteMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ResetBio resets all changes to the "bio" field.
func (m *AthleteMutation) ResetBio() {
	m.bio = nil
}

// SetFirstName sets the "first_name" field.
func (m *AthleteMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AthleteMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Athlete entity.
// If the Athlete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AthleteMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AthleteMutation) ResetFirstName() {
	m.first_name = nil
}

// SetMiddleName sets the "middle_name" field.
func (m *AthleteMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *AthleteMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the Athlete entity.
// If the Athlete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AthleteMutation) OldMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ClearMiddleName clears the value of the "middle_name" field.
func (m *AthleteMutation) ClearMiddleName() {
	m.middle_name = nil
	m.clearedFields[athlete.FieldMiddleName] = struct{}{}
}

// MiddleNameCleared returns if the "middle_name" field was cleared in this mutation.
func (m *AthleteMutation) MiddleNameCleared() bool {
	_, ok := m.clearedFields[athlete.FieldMiddleName]
	return ok
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *AthleteMutation) ResetMiddleName() {
	m.middle_name = nil
	delete(m.clearedFields, athlete.FieldMiddleName)
}

// SetLastName sets the "last_name" field.
func (m *AthleteMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AthleteMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Athlete entity.
// If the Athlete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AthleteMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AthleteMutation) ResetLastName() {
	m.last_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AthleteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AthleteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Athlete entity.
// If the Athlete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AthleteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AthleteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AthleteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AthleteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Athlete entity.
// If the Athlete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AthleteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AthleteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddSchoolIDs adds the "schools" edge to the School entity by ids.
func (m *AthleteMutation) AddSchoolIDs(ids ...int) {
	if m.schools == nil {
		m.schools = make(map[int]struct{})
	}
	for i := range ids {
		m.schools[ids[i]] = struct{}{}
	}
}

// ClearSchools clears the "schools" edge to the School entity.
func (m *AthleteMutation) ClearSchools() {
	m.clearedschools = true
}

// SchoolsCleared reports if the "schools" edge to the School entity was cleared.
func (m *AthleteMutation) SchoolsCleared() bool {
	return m.clearedschools
}

// RemoveSchoolIDs removes the "schools" edge to the School entity by IDs.
func (m *AthleteMutation) RemoveSchoolIDs(ids ...int) {
	if m.removedschools == nil {
		m.removedschools = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.schools, ids[i])
		m.removedschools[ids[i]] = struct{}{}
	}
}

// RemovedSchools returns the removed IDs of the "schools" edge to the School entity.
func (m *AthleteMutation) RemovedSchoolsIDs() (ids []int) {
	for id := range m.removedschools {
		ids = append(ids, id)
	}
	return
}

// SchoolsIDs returns the "schools" edge IDs in the mutation.
func (m *AthleteMutation) SchoolsIDs() (ids []int) {
	for id := range m.schools {
		ids = append(ids, id)
	}
	return
}

// ResetSchools resets all changes to the "schools" edge.
func (m *AthleteMutation) ResetSchools() {
	m.schools = nil
	m.clearedschools = false
	m.removedschools = nil
}

// Where appends a list predicates to the AthleteMutation builder.
func (m *AthleteMutation) Where(ps ...predicate.Athlete) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AthleteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Athlete).
func (m *AthleteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AthleteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.bio != nil {
		fields = append(fields, athlete.FieldBio)
	}
	if m.first_name != nil {
		fields = append(fields, athlete.FieldFirstName)
	}
	if m.middle_name != nil {
		fields = append(fields, athlete.FieldMiddleName)
	}
	if m.last_name != nil {
		fields = append(fields, athlete.FieldLastName)
	}
	if m.created_at != nil {
		fields = append(fields, athlete.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, athlete.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AthleteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case athlete.FieldBio:
		return m.Bio()
	case athlete.FieldFirstName:
		return m.FirstName()
	case athlete.FieldMiddleName:
		return m.MiddleName()
	case athlete.FieldLastName:
		return m.LastName()
	case athlete.FieldCreatedAt:
		return m.CreatedAt()
	case athlete.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AthleteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case athlete.FieldBio:
		return m.OldBio(ctx)
	case athlete.FieldFirstName:
		return m.OldFirstName(ctx)
	case athlete.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case athlete.FieldLastName:
		return m.OldLastName(ctx)
	case athlete.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case athlete.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Athlete field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AthleteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case athlete.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case athlete.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case athlete.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case athlete.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case athlete.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case athlete.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Athlete field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AthleteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AthleteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AthleteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Athlete numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AthleteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(athlete.FieldMiddleName) {
		fields = append(fields, athlete.FieldMiddleName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AthleteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AthleteMutation) ClearField(name string) error {
	switch name {
	case athlete.FieldMiddleName:
		m.ClearMiddleName()
		return nil
	}
	return fmt.Errorf("unknown Athlete nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AthleteMutation) ResetField(name string) error {
	switch name {
	case athlete.FieldBio:
		m.ResetBio()
		return nil
	case athlete.FieldFirstName:
		m.ResetFirstName()
		return nil
	case athlete.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case athlete.FieldLastName:
		m.ResetLastName()
		return nil
	case athlete.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case athlete.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Athlete field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AthleteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schools != nil {
		edges = append(edges, athlete.EdgeSchools)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AthleteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case athlete.EdgeSchools:
		ids := make([]ent.Value, 0, len(m.schools))
		for id := range m.schools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AthleteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedschools != nil {
		edges = append(edges, athlete.EdgeSchools)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AthleteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case athlete.EdgeSchools:
		ids := make([]ent.Value, 0, len(m.removedschools))
		for id := range m.removedschools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AthleteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschools {
		edges = append(edges, athlete.EdgeSchools)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AthleteMutation) EdgeCleared(name string) bool {
	switch name {
	case athlete.EdgeSchools:
		return m.clearedschools
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AthleteMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Athlete unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AthleteMutation) ResetEdge(name string) error {
	switch name {
	case athlete.EdgeSchools:
		m.ResetSchools()
		return nil
	}
	return fmt.Errorf("unknown Athlete edge %s", name)
}

// AthleteSchoolMutation represents an operation that mutates the AthleteSchool nodes in the graph.
type AthleteSchoolMutation struct {
	config
	op             Op
	typ            string
	start_date     *time.Time
	end_date       *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	athlete        *int
	clearedathlete bool
	school         *int
	clearedschool  bool
	done           bool
	oldValue       func(context.Context) (*AthleteSchool, error)
	predicates     []predicate.AthleteSchool
}

var _ ent.Mutation = (*AthleteSchoolMutation)(nil)

// athleteschoolOption allows management of the mutation configuration using functional options.
type athleteschoolOption func(*AthleteSchoolMutation)

// newAthleteSchoolMutation creates new mutation for the AthleteSchool entity.
func newAthleteSchoolMutation(c config, op Op, opts ...athleteschoolOption) *AthleteSchoolMutation {
	m := &AthleteSchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeAthleteSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AthleteSchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AthleteSchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetAthleteID sets the "athlete_id" field.
func (m *AthleteSchoolMutation) SetAthleteID(i int) {
	m.athlete = &i
}

// AthleteID returns the value of the "athlete_id" field in the mutation.
func (m *AthleteSchoolMutation) AthleteID() (r int, exists bool) {
	v := m.athlete
	if v == nil {
		return
	}
	return *v, true
}

// ResetAthleteID resets all changes to the "athlete_id" field.
func (m *AthleteSchoolMutation) ResetAthleteID() {
	m.athlete = nil
}

// SetSchoolID sets the "school_id" field.
func (m *AthleteSchoolMutation) SetSchoolID(i int) {
	m.school = &i
}

// SchoolID returns the value of the "school_id" field in the mutation.
func (m *AthleteSchoolMutation) SchoolID() (r int, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// ResetSchoolID resets all changes to the "school_id" field.
func (m *AthleteSchoolMutation) ResetSchoolID() {
	m.school = nil
}

// SetStartDate sets the "start_date" field.
func (m *AthleteSchoolMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *AthleteSchoolMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *AthleteSchoolMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *AthleteSchoolMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *AthleteSchoolMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *AthleteSchoolMutation) ResetEndDate() {
	m.end_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AthleteSchoolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AthleteSchoolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AthleteSchoolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAthlete clears the "athlete" edge to the Athlete entity.
func (m *AthleteSchoolMutation) ClearAthlete() {
	m.clearedathlete = true
}

// AthleteCleared reports if the "athlete" edge to the Athlete entity was cleared.
func (m *AthleteSchoolMutation) AthleteCleared() bool {
	return m.clearedathlete
}

// AthleteIDs returns the "athlete" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AthleteID instead. It exists only for internal usage by the builders.
func (m *AthleteSchoolMutation) AthleteIDs() (ids []int) {
	if id := m.athlete; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAthlete resets all changes to the "athlete" edge.
func (m *AthleteSchoolMutation) ResetAthlete() {
	m.athlete = nil
	m.clearedathlete = false
}

// ClearSchool clears the "school" edge to the School entity.
func (m *AthleteSchoolMutation) ClearSchool() {
	m.clearedschool = true
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *AthleteSchoolMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *AthleteSchoolMutation) SchoolIDs() (ids []int) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *AthleteSchoolMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// Where appends a list predicates to the AthleteSchoolMutation builder.
func (m *AthleteSchoolMutation) Where(ps ...predicate.AthleteSchool) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AthleteSchoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AthleteSchool).
func (m *AthleteSchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AthleteSchoolMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.athlete != nil {
		fields = append(fields, athleteschool.FieldAthleteID)
	}
	if m.school != nil {
		fields = append(fields, athleteschool.FieldSchoolID)
	}
	if m.start_date != nil {
		fields = append(fields, athleteschool.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, athleteschool.FieldEndDate)
	}
	if m.created_at != nil {
		fields = append(fields, athleteschool.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AthleteSchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case athleteschool.FieldAthleteID:
		return m.AthleteID()
	case athleteschool.FieldSchoolID:
		return m.SchoolID()
	case athleteschool.FieldStartDate:
		return m.StartDate()
	case athleteschool.FieldEndDate:
		return m.EndDate()
	case athleteschool.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AthleteSchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema AthleteSchool does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AthleteSchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case athleteschool.FieldAthleteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAthleteID(v)
		return nil
	case athleteschool.FieldSchoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolID(v)
		return nil
	case athleteschool.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case athleteschool.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case athleteschool.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AthleteSchool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AthleteSchoolMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AthleteSchoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AthleteSchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AthleteSchool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AthleteSchoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AthleteSchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AthleteSchoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AthleteSchool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AthleteSchoolMutation) ResetField(name string) error {
	switch name {
	case athleteschool.FieldAthleteID:
		m.ResetAthleteID()
		return nil
	case athleteschool.FieldSchoolID:
		m.ResetSchoolID()
		return nil
	case athleteschool.FieldStartDate:
		m.ResetStartDate()
		return nil
	case athleteschool.FieldEndDate:
		m.ResetEndDate()
		return nil
	case athleteschool.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AthleteSchool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AthleteSchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.athlete != nil {
		edges = append(edges, athleteschool.EdgeAthlete)
	}
	if m.school != nil {
		edges = append(edges, athleteschool.EdgeSchool)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AthleteSchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case athleteschool.EdgeAthlete:
		if id := m.athlete; id != nil {
			return []ent.Value{*id}
		}
	case athleteschool.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AthleteSchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AthleteSchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AthleteSchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedathlete {
		edges = append(edges, athleteschool.EdgeAthlete)
	}
	if m.clearedschool {
		edges = append(edges, athleteschool.EdgeSchool)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AthleteSchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case athleteschool.EdgeAthlete:
		return m.clearedathlete
	case athleteschool.EdgeSchool:
		return m.clearedschool
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AthleteSchoolMutation) ClearEdge(name string) error {
	switch name {
	case athleteschool.EdgeAthlete:
		m.ClearAthlete()
		return nil
	case athleteschool.EdgeSchool:
		m.ClearSchool()
		return nil
	}
	return fmt.Errorf("unknown AthleteSchool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AthleteSchoolMutation) ResetEdge(name string) error {
	switch name {
	case athleteschool.EdgeAthlete:
		m.ResetAthlete()
		return nil
	case athleteschool.EdgeSchool:
		m.ResetSchool()
		return nil
	}
	return fmt.Errorf("unknown AthleteSchool edge %s", name)
}

// SchoolMutation represents an operation that mutates the School nodes in the graph.
type SchoolMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	description         *string
	street_address      *string
	city                *string
	country             *string
	administration_area *string
	postal_code         *string
	lat                 *float64
	addlat              *float64
	lng                 *float64
	addlng              *float64
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	athletes            map[int]struct{}
	removedathletes     map[int]struct{}
	clearedathletes     bool
	done                bool
	oldValue            func(context.Context) (*School, error)
	predicates          []predicate.School
}

var _ ent.Mutation = (*SchoolMutation)(nil)

// schoolOption allows management of the mutation configuration using functional options.
type schoolOption func(*SchoolMutation)

// newSchoolMutation creates new mutation for the School entity.
func newSchoolMutation(c config, op Op, opts ...schoolOption) *SchoolMutation {
	m := &SchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchoolID sets the ID field of the mutation.
func withSchoolID(id int) schoolOption {
	return func(m *SchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *School
		)
		m.oldValue = func(ctx context.Context) (*School, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().School.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchool sets the old School of the mutation.
func withSchool(node *School) schoolOption {
	return func(m *SchoolMutation) {
		m.oldValue = func(context.Context) (*School, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchoolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().School.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchoolMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SchoolMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SchoolMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SchoolMutation) ResetDescription() {
	m.description = nil
}

// SetStreetAddress sets the "street_address" field.
func (m *SchoolMutation) SetStreetAddress(s string) {
	m.street_address = &s
}

// StreetAddress returns the value of the "street_address" field in the mutation.
func (m *SchoolMutation) StreetAddress() (r string, exists bool) {
	v := m.street_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetAddress returns the old "street_address" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldStreetAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetAddress: %w", err)
	}
	return oldValue.StreetAddress, nil
}

// ResetStreetAddress resets all changes to the "street_address" field.
func (m *SchoolMutation) ResetStreetAddress() {
	m.street_address = nil
}

// SetCity sets the "city" field.
func (m *SchoolMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *SchoolMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *SchoolMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *SchoolMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SchoolMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *SchoolMutation) ResetCountry() {
	m.country = nil
}

// SetAdministrationArea sets the "administration_area" field.
func (m *SchoolMutation) SetAdministrationArea(s string) {
	m.administration_area = &s
}

// AdministrationArea returns the value of the "administration_area" field in the mutation.
func (m *SchoolMutation) AdministrationArea() (r string, exists bool) {
	v := m.administration_area
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministrationArea returns the old "administration_area" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldAdministrationArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministrationArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministrationArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministrationArea: %w", err)
	}
	return oldValue.AdministrationArea, nil
}

// ResetAdministrationArea resets all changes to the "administration_area" field.
func (m *SchoolMutation) ResetAdministrationArea() {
	m.administration_area = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *SchoolMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *SchoolMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *SchoolMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetLat sets the "lat" field.
func (m *SchoolMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *SchoolMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *SchoolMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *SchoolMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *SchoolMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetLng sets the "lng" field.
func (m *SchoolMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *SchoolMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *SchoolMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *SchoolMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *SchoolMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SchoolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SchoolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SchoolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SchoolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SchoolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SchoolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAthleteIDs adds the "athletes" edge to the Athlete entity by ids.
func (m *SchoolMutation) AddAthleteIDs(ids ...int) {
	if m.athletes == nil {
		m.athletes = make(map[int]struct{})
	}
	for i := range ids {
		m.athletes[ids[i]] = struct{}{}
	}
}

// ClearAthletes clears the "athletes" edge to the Athlete entity.
func (m *SchoolMutation) ClearAthletes() {
	m.clearedathletes = true
}

// AthletesCleared reports if the "athletes" edge to the Athlete entity was cleared.
func (m *SchoolMutation) AthletesCleared() bool {
	return m.clearedathletes
}

// RemoveAthleteIDs removes the "athletes" edge to the Athlete entity by IDs.
func (m *SchoolMutation) RemoveAthleteIDs(ids ...int) {
	if m.removedathletes == nil {
		m.removedathletes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.athletes, ids[i])
		m.removedathletes[ids[i]] = struct{}{}
	}
}

// RemovedAthletes returns the removed IDs of the "athletes" edge to the Athlete entity.
func (m *SchoolMutation) RemovedAthletesIDs() (ids []int) {
	for id := range m.removedathletes {
		ids = append(ids, id)
	}
	return
}

// AthletesIDs returns the "athletes" edge IDs in the mutation.
func (m *SchoolMutation) AthletesIDs() (ids []int) {
	for id := range m.athletes {
		ids = append(ids, id)
	}
	return
}

// ResetAthletes resets all changes to the "athletes" edge.
func (m *SchoolMutation) ResetAthletes() {
	m.athletes = nil
	m.clearedathletes = false
	m.removedathletes = nil
}

// Where appends a list predicates to the SchoolMutation builder.
func (m *SchoolMutation) Where(ps ...predicate.School) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SchoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (School).
func (m *SchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchoolMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, school.FieldName)
	}
	if m.description != nil {
		fields = append(fields, school.FieldDescription)
	}
	if m.street_address != nil {
		fields = append(fields, school.FieldStreetAddress)
	}
	if m.city != nil {
		fields = append(fields, school.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, school.FieldCountry)
	}
	if m.administration_area != nil {
		fields = append(fields, school.FieldAdministrationArea)
	}
	if m.postal_code != nil {
		fields = append(fields, school.FieldPostalCode)
	}
	if m.lat != nil {
		fields = append(fields, school.FieldLat)
	}
	if m.lng != nil {
		fields = append(fields, school.FieldLng)
	}
	if m.created_at != nil {
		fields = append(fields, school.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, school.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case school.FieldName:
		return m.Name()
	case school.FieldDescription:
		return m.Description()
	case school.FieldStreetAddress:
		return m.StreetAddress()
	case school.FieldCity:
		return m.City()
	case school.FieldCountry:
		return m.Country()
	case school.FieldAdministrationArea:
		return m.AdministrationArea()
	case school.FieldPostalCode:
		return m.PostalCode()
	case school.FieldLat:
		return m.Lat()
	case school.FieldLng:
		return m.Lng()
	case school.FieldCreatedAt:
		return m.CreatedAt()
	case school.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case school.FieldName:
		return m.OldName(ctx)
	case school.FieldDescription:
		return m.OldDescription(ctx)
	case school.FieldStreetAddress:
		return m.OldStreetAddress(ctx)
	case school.FieldCity:
		return m.OldCity(ctx)
	case school.FieldCountry:
		return m.OldCountry(ctx)
	case school.FieldAdministrationArea:
		return m.OldAdministrationArea(ctx)
	case school.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case school.FieldLat:
		return m.OldLat(ctx)
	case school.FieldLng:
		return m.OldLng(ctx)
	case school.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case school.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown School field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case school.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case school.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case school.FieldStreetAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetAddress(v)
		return nil
	case school.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case school.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case school.FieldAdministrationArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministrationArea(v)
		return nil
	case school.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case school.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case school.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case school.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case school.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchoolMutation) AddedFields() []string {
	var fields []string
	if m.addlat != nil {
		fields = append(fields, school.FieldLat)
	}
	if m.addlng != nil {
		fields = append(fields, school.FieldLng)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case school.FieldLat:
		return m.AddedLat()
	case school.FieldLng:
		return m.AddedLng()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case school.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case school.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	}
	return fmt.Errorf("unknown School numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown School nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchoolMutation) ResetField(name string) error {
	switch name {
	case school.FieldName:
		m.ResetName()
		return nil
	case school.FieldDescription:
		m.ResetDescription()
		return nil
	case school.FieldStreetAddress:
		m.ResetStreetAddress()
		return nil
	case school.FieldCity:
		m.ResetCity()
		return nil
	case school.FieldCountry:
		m.ResetCountry()
		return nil
	case school.FieldAdministrationArea:
		m.ResetAdministrationArea()
		return nil
	case school.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case school.FieldLat:
		m.ResetLat()
		return nil
	case school.FieldLng:
		m.ResetLng()
		return nil
	case school.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case school.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.athletes != nil {
		edges = append(edges, school.EdgeAthletes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeAthletes:
		ids := make([]ent.Value, 0, len(m.athletes))
		for id := range m.athletes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedathletes != nil {
		edges = append(edges, school.EdgeAthletes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeAthletes:
		ids := make([]ent.Value, 0, len(m.removedathletes))
		for id := range m.removedathletes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedathletes {
		edges = append(edges, school.EdgeAthletes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case school.EdgeAthletes:
		return m.clearedathletes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown School unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchoolMutation) ResetEdge(name string) error {
	switch name {
	case school.EdgeAthletes:
		m.ResetAthletes()
		return nil
	}
	return fmt.Errorf("unknown School edge %s", name)
}
